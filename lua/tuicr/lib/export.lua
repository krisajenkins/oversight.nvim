-- Markdown export for review feedback

local M = {}

---Convert a session to markdown format optimized for LLM feedback
---@param session ReviewSession Review session
---@param repo GitRepository Git repository
---@return string markdown Markdown string
function M.to_markdown(session, repo)
	local lines = {}

	-- Header
	local repo_name = vim.fn.fnamemodify(repo:get_root(), ":t")
	table.insert(lines, "# Code Review Feedback")
	table.insert(lines, "")
	table.insert(lines, string.format("Repository: %s", repo_name))
	table.insert(lines, string.format("Branch: %s", repo:get_branch() or "detached"))
	table.insert(lines, string.format("Commit: %s", repo:get_head():sub(1, 8)))
	table.insert(lines, "")

	-- Instructions for the agent
	table.insert(lines, "## Instructions")
	table.insert(lines, "")
	table.insert(
		lines,
		"The following feedback has been collected during code review. Please address the issues and suggestions below."
	)
	table.insert(lines, "")
	table.insert(lines, "Comment types:")
	table.insert(lines, "- **ISSUE**: Problems that should be fixed")
	table.insert(lines, "- **SUGGESTION**: Recommended improvements")
	table.insert(lines, "- **NOTE**: General observations or context")
	table.insert(lines, "- **PRAISE**: Good work to preserve")
	table.insert(lines, "")

	-- Summary
	local reviewed, total = session:get_progress()
	local counts = session:get_comment_counts()
	local total_comments = counts.note + counts.suggestion + counts.issue + counts.praise

	table.insert(lines, "## Summary")
	table.insert(lines, "")
	table.insert(lines, string.format("- Files reviewed: %d/%d", reviewed, total))
	table.insert(lines, string.format("- Total comments: %d", total_comments))
	if counts.issue > 0 then
		table.insert(lines, string.format("  - Issues: %d", counts.issue))
	end
	if counts.suggestion > 0 then
		table.insert(lines, string.format("  - Suggestions: %d", counts.suggestion))
	end
	if counts.note > 0 then
		table.insert(lines, string.format("  - Notes: %d", counts.note))
	end
	if counts.praise > 0 then
		table.insert(lines, string.format("  - Praise: %d", counts.praise))
	end
	table.insert(lines, "")

	-- Group comments by file
	local comments_by_file = {}
	for _, comment in ipairs(session.comments) do
		comments_by_file[comment.file] = comments_by_file[comment.file] or {}
		table.insert(comments_by_file[comment.file], comment)
	end

	-- Sort files alphabetically
	local sorted_files = {}
	for file, _ in pairs(comments_by_file) do
		table.insert(sorted_files, file)
	end
	table.sort(sorted_files)

	-- Output comments per file
	table.insert(lines, "## Feedback by File")
	table.insert(lines, "")

	for _, file in ipairs(sorted_files) do
		local file_comments = comments_by_file[file]

		-- Sort comments by line number
		table.sort(file_comments, function(a, b)
			local line_a = a.line or 0
			local line_b = b.line or 0
			return line_a < line_b
		end)

		table.insert(lines, string.format("### %s", file))
		table.insert(lines, "")

		for _, comment in ipairs(file_comments) do
			-- Format location
			local location
			if comment.line then
				if comment.side == "old" then
					location = string.format("Line ~%d (deleted)", comment.line)
				else
					location = string.format("Line %d", comment.line)
				end
			else
				location = "(file-level)"
			end

			-- Format type label
			local type_label = comment.type:upper()

			table.insert(lines, string.format("**[%s]** %s", type_label, location))
			table.insert(lines, "")

			-- Indent comment text
			for _, text_line in ipairs(vim.split(comment.text, "\n")) do
				table.insert(lines, "> " .. text_line)
			end
			table.insert(lines, "")
		end
	end

	-- Footer
	table.insert(lines, "---")
	table.insert(lines, "")
	table.insert(lines, "*Generated by tuicr - Code Review for AI Changes*")

	return table.concat(lines, "\n")
end

---Export session to a file
---@param session ReviewSession Review session
---@param repo GitRepository Git repository
---@param output_path string Output file path
---@return boolean success True if export succeeded
function M.to_file(session, repo, output_path)
	local markdown = M.to_markdown(session, repo)
	local lines = vim.split(markdown, "\n")

	local ok = pcall(function()
		vim.fn.writefile(lines, output_path)
	end)

	return ok
end

return M
